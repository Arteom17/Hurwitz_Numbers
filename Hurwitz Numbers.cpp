#include <iostream>   //  подключаю библиотеку iostream
#include <clocale>    //  подключаю библиотеку clocale
#include <windows.h>  //  подключаю библиотеку windwos.h
#include <vector>     //  подключаю библиотеку vector
#include <ctime>      //  подключаю библиотеку ctime
#include <thread>     //  подключаю библиотеку thread

const auto processor_count = std::thread::hardware_concurrency(); // получаю число виртуальных потоков системы
using namespace std; //полe имен std
vector<short> multi(vector<vector<short>>& tr, short& n, vector<short>& key, short& m) //функция произведения транспозиций
{
	vector<short> per(n); //вектор под конечную перестановку
	//for (int i = 0; i < n; i++) per[i] = i; // делаю перестановку тождественной 
	for (int i = 0; i < n; i++)//иду по перестановке
	{
		int z = i;//переменная для перемножения транспозиций
		for (int j = 0; j < m; j++) //цикл в котором происходит перемножение
		{
			z = tr[key[j]][z];//перемножение транспозиций
		}
		per[i] = z;//записывание результата в перестановку
	}
	return per;//возврат перестановки
}

short our(vector<short>& per, short& n, vector<vector<short>>& M)//функция проверки циклического типа перестановки
{
	vector<short> key(n);//массив флагов
	for (size_t i = 0; i < n; i++) key[i] = 0;//обнуляю флаги
	short ki = 0;//счетчик обхода перестановки
	short z;//переменная для индекса в перестановке
	while (ki != n)//проверка того, что что мы еще не проверили всю перестановку
	{
		z = 0;//обнуление счетчика
		while (key[z] != 0) z++;//находим не использованный элемент
		key[z] = 1;//отмечаю флаг первого на этот раз элемента
		short k = 1; //счетчик длинны цикла
		short z1 = per[z];//переменная для обхода цикла
		while (z != z1)//пока не обошли цикл
		{
			key[z1] = 1;//отмечаем пройденный элемент
			k++;//увеличиваем счетчик длинны цикла
			z1 = per[z1];//переходим у следующему элементу
		}
		ki += k;//к счетчику перестановки прибавляем длину пройденного цикла
		z = 0;// обнуляем счетчик для того чтобы пройтись по массиву циклического типа
		while (z < M[0].size() && M[0][z] != k)//ищем есть ли такой циклический тип
			z++;
		if (z == M[0].size()) break;//если не нашли данный тип, выходим из анализа перестановки
		if (M[2][z] < M[1][z]) M[2][z]++; //если не превышено количество таких циклов увеличиваем счетчик количества таких циклов
		else break;//иначе выходим из анализа
	}
	short bl = 1;//создаем флаг
	if (ki != n) bl = 0;//если вышли из анализа раньше то bad per
	for (z = 0; z < M[0].size(); z++)//просто цикл обнуления счетчиков количества циклов
	{
		M[2][z] = 0;//обнуление элемента
	}
	return bl;//возврат флага
}

void schet(vector<vector<short>>& tr, short& n, vector<short>& i, short i1, short m1, short mx, short my, vector<int>& x, short& m, vector<vector<short>> M, vector<vector<short>>& key)
//рекурсивная процедура для перебора комбинаций транспозиций, их перемножения и подсчета верных
{
	bool bl = 0;//флаг для определения критериев верхней границы
	for (int j = 0; j < i[i1]; j++)//проверка более высоких разрядов на приближение к границе
		if (key[i1][j] < my)bl = 1; //если есть хотя бы один разряд не превышающий границы
	short my1 = ((bl) ? m1 - 1 : (i[i1] == m - 1) ? my - 1 : my);//если есть маленькие разряды,
	//то граница = размерности сс числа, иначе если крайний разряд, то число должно быть на еденицу меньше
	my1 = (my1 == m1) ? my1 - 1 : my1;//так как разряд не может быть равен разрядности
	for (int j = (key[i1][i[i1]] > -1) ? 0 : mx; j <= my1; j++) //сам цикл перебора
	{
		key[i1][i[i1]] = j; i[i1]++; //записываем число в разряд и увеличиваем счетчик разряда
		if (i[i1] == m)//органичение перебора, если все разряды подобраны
		{
			vector<short> per(n);//создаем вектор под перестановку
			per = multi(tr, n, key[i1], m);//перемножаем транспозиции
			x[i1] = x[i1] + our(per, n, M);//проверяем наша ли транспозиция и прибавляем к счетчику число

		}
		else schet(tr, n, i, i1, m1, mx, my, x, m, M, key);//рекурсивный вызов если не подобраны все разряды
		i[i1]--;//уменьшаем счетчик разрядов
	}
}
int multischet(vector<vector<short>>& tr, short& n, short& m1, int& x, short& m, vector<vector<short>>& M)
//функция для деления перебора на потоки и суммирование полученных в потоках значений
{
	short my = m1;//задание верхней границы
	short delt = m1 / processor_count;//высчитывание шага
	short mx = delt * (processor_count - 1);//задание нижней границы
	vector<thread> fx(processor_count);//создание вектора потоков
	vector<short>ii(processor_count);//создание вектора счетчиков для потоков
	vector<vector<short> > key(processor_count, vector<short>(m));//создание вектора векторов индексов транспозиций
	vector<int> xx(processor_count);//создание вектора счетчиков хороших наборов транспозиций
	for (short i1 = 0; i1 < processor_count; i1++) //цикл в котором мы инициализируем потоки
	{
		for (int i = 0; i < m; i++)//обнуление вектора разрядов
			key[i1][i] = -1;
		ii[i1] = 0;//инициализация счетчика разрядов
		xx[i1] = 0;//инициализация счетчика хороших наборов
		//инициализация потока и передача в него лямбда функции с вызовом функции schet
		fx[i1] = thread([&tr, &n, &ii, i1, m1, mx, my, &xx, &m, M, &key]() {schet(tr, n, ii, i1, m1, mx, my, xx, m, M, key); });
		my = mx; //смена верхней границы
		mx -= delt;// смена нижней границы
	}
	for (int i = 0; i < processor_count; i++)
	{
		fx[i].join();//ждем потоки
	}
	for (int i = 0; i < processor_count; i++)
	{
		x += xx[i];//суммирование всех хороших комбинаций транспозиций
	}
	return x;//возврат числа всех хороших транспозиций 
}

int fact(short& n)
//функция счета факториала
{
	int x = 1;//задание переменной для счета
	for (int i = 1; i <= n; i++)
	{
		x *= i;//счет факториала
	}
	return x;//возврат полученного значения
}
void input(short& m, vector<vector<short>>& M)
{
	cout << "m, M + 0\n\"0\" = end of enter\n";//вывод формы ввода
	cin >> m;//ввод количества транспозиций
	short n = 1;//просто временная переменная для ввода циклического типа 
	while (n > 0)//пока не встретили отрицательное число
	{
		cin >> n;//ввод основания
		if (n > 0)//обрботка нечетного ввода
		{
			M[0].push_back(n);//добавление в конец вектора основания 
			cin >> n;//ввод степени
			M[1].push_back(n);//добавление степени в конец вектора
			M[2].push_back(0);//инициализация счетчика
		}
	}
}
short chek(short& m, vector<vector<short>>& M, short& n, short k)
{
	short ki = 0;//счетчик количества всех циклов
	short chet = 0;//переменная для определения четности
	for (int i = 0; i < k; i++)//цикл по вектору циклического типа
	{
		n += M[0][i] * M[1][i];//считаем n
		ki += M[1][i];//считаем количество циклов
		chet += (1 - M[0][i] % 2) * M[1][i];//определяем четность
	}
	if (m < n - ki)//условие выхода первое(m<минимального значения)
	{
		cout << "it`s wrong\n";//вывод ошибки
		return 1;//возврат кода ошибки
	}
	else if (chet % 2 != m % 2)//условие выхода второе (проверка четности)
	{
		cout << "it`s wrong\n";//вывод ошибки
		return 2;//возврат кода ошибки
	}
}
void intr(vector<vector<short>>& tr, short n)
{
	short x = 0;//счетчик транспозиции
	for (int i = 0; i < n - 1; i++)//цикл по первым элементам транспозиции
	{
		for (int j = i + 1; j < n; j++)//цикл по вторым элементам транспозиции
		{
			for (int k = 0; k < n; k++)//цикл для заполнения тождественной перестановки
			{
				tr[x][k] = k;//запись биекции i->i
			}
			tr[x][i] = j;//запись первого элемента транспозиции
			tr[x][j] = i;//запись второго элемента транспозиции
			x++;//увеличение счетчика транспозиции
		}
	}
}
double hurvic(vector<vector<short>>& tr, short& n, short& m1, short& m, vector<vector<short>>& M)
{
	int x = 0;//счетчик хороших комбинаций транспозиций
	int y = multischet(tr, n, m1, x, m, M);//вызов функции деления на потоки и получение числа всех хороших
	return (double(y) / fact(n));//вычисление числа гурвица
}
int main()
{
	short m;//создание переменной хранящей количество транспозиций в произведении
	vector<vector<short>> M(3);//создание вектора  для хранения циклической структуры
	input(m, M);
	auto start = chrono::high_resolution_clock::now();//получаем время начала
	short k = short(size(M[0]));//получение числа разных циклов
	short n = 0;
	short ch = chek(m, M, n, k);
	if (ch) return ch;
	short m1 = n * (n - 1) / 2;//вычисление количества всех транспозиций для данного n
	vector<vector<short>> tr(m1, vector<short>(n));//создание вектора для транспозиций
	intr(tr, n);
	double h = hurvic(tr, n, m1, m, M);
	auto end = chrono::high_resolution_clock::now();//получаем время конца
	chrono::duration<float>  duration = end - start;//считаем разницу во времени
	cout << h << endl;//вывод числа Гурвица
	cout << "time: " << duration.count() << " s\n";//выводим время в секундах
	return 0;//возврат кода 
}
